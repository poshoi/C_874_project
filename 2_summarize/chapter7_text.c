#include<stdio.h>
/*
=========1.========
输入10个整数,将这10个整数按升序排列输出,并且奇数在前,偶数在后
<思想>:讲输入的10个整数 按照奇偶性扽别放在数组a的左部分和右部分,
方法就是设置两个整型变量 odd  even,分别表示奇数和偶数在舒徐中元素的下标.
odd初始值为0,没存放一个奇数odd+1, even初始值为9,每存放一个even -1

*/

void jiou()
{
    int i, j, even, odd, n, t, a[10];
    odd = 0; // 奇数 
    even = 9;  //偶数
    for(i=0,i<10;i++){
        scanf("%d",&n);
        if(n%2==0)
            a[add++] = n;
        else
            a[even--] = n;  //偶数放在右边
    }
    for(i=0;i<odd-1;i++)   //通过选择排序进行升序排列
    {
        n = i;
        for(j=i+1;j<odd;j++){
            if(a[j]<a[n]){
                n=j;
            }
            if(n!=i){
                t = a[i];
                a[i] = a[n];
                a[n] = t;
            }
        }

        for(i = odd;i<9;i++){
            n=i;
            for(j=i+1;j<10;j++)
                if(a[j]<a[n])
                n=j;
            if(n!=i){
                t=a[i];
                a[i]=a[n];
                a[n]=t;
            }
        }

        for(i=0;i<10;i++){
            printf("%d",a[i]);
        }
    }
}


/*
=========2.=============
从键盘输入10个整数,编程实现将其中最大的数和最小的数的位置对换后, 在输出调整后的数组
<思想>: 先输入的10个整数存入数组A中,然后通过对比找到最大值和最小值元素的下标,
分别用变量MAX和 MIN表示,最后交换最大数和最小数

*/

void Max_Min(){
    int i, max, min, a[10];
    printf("Input 10 integer number:\n");
    for(i=0;i<10;i++){
        scanf("%d",&a[i]);
    }
    max = 0;
    min = 0;
    for(i=1;i<10;i++){  //求最大值和最小值的元素下标
        if(a[i]>a[max])
            max = i;
        if(a[i]<a[min])
            min = i;
    }
    i=a[max];
    a[max]=a[min];
    a[min]=i;
    for(i=0;i<10;i++){
        printf("%d",&a[i]);
    }
}

/*
=========3.=========
编写一个程序,其功能是给一维数组A输入任意的6个整数,假设为5 7 4 8 9 1,
然后建立一个具有一下内容的方阵,并打印下来
5 7 4 8 9 1
1 5 7 4 8 9 
8 1 5 7 4 8
8 9 1 5 7 4
4 8 9 1 5 7
7 4 8 9 1 5

<思想>:将数组A的数据循环显示6次,每次显示后将数组元素进行循环右移
方法:将a[5]保存到变量t中,再将a[0]~a[4]往右移一个位置,即a[5]=a[4],
a[4]=a[3],....a[1]=a[0],然后将a[0]=t.
*/


void youyi(
    int i , j, t ,a[6];
    printf("input 6 integer number:\n");
    for(i=0;i<6;i++)
        scanf("%d",&a[i]);
    for(i=0;i<6;i++)  
    {
        for(j=0;i<6;j++)   //显示结果
            printf("%d",a[j]);
        printf("\n");
        t = a[5];
        for(j=5;j>0;j--){
            a[j]=a[j-1];  //右移动
        }
        a[0] = t;
    }
)

/*
=======4.=========
输入5*5阶的矩阵,
A.求两条对角线上的个元素之和
B.求两条对角线上行、列小表均为偶数的个元素之积
<思想>: 通过两重for循环将键盘输入的5*5的矩阵元素存放在二维数组A中,采用累加和算法:sum = sum+a[i][i]
累计左对角线上的元素之和,同时用sum = sum+a[i][4-i],累计右对角线上的元素之和(除去两对角线上的交叉元素a[2][2])
采用累成算法:mul = mul*a[i][i],累乘左对角线上行、列下标均为偶数的元素之积,
同时用mul=mul*a[i][4-i]累成右对角线上行、列下标均为偶数的元素之积(除去两对角线上的交叉元素a[2][2])

*/

void array(){
    int i, j, sum =0, mul =1, a[5][5];
    printf("input 5*5 array\n");  //输入5*5的矩阵
    for(i = 0;i<5;i++){
        for(j=0;j<5;j++){
            scanf("%d",&a[i][j]);
        }
    }
    printf("\n");

    for(i=0;i<5;i++){
        sum += a[i][i];  //对左对角线 累加
        if(i !=2)   //对右对角线的元素进行累加
            sum +=a[i][4-i];
        if(i%2 !=0)  //如果行下标为奇数, 进入下一次循环
            continue;
        mul *=a[i][i];  //对左对角线上行、列下标均为偶数的元素进行累乘
        if(i!=2)  //对右对角线上行、列下标均为偶数的元素进行累乘(中间的元素除外)
            mul *=a[i][4-i];
    }
    printf("sum = %d  mul = %d\n",sum ,mul);
}